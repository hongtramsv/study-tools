<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Vui h·ªçc ph√©p nh√¢n</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Baloo 2", cursive;
        background: #fdf6fb;
      }
      #shootGame {
        max-width: 900px;
        margin: 0 auto;
        background: linear-gradient(180deg, #ffe4f0, #fff0f6);
        border-radius: 18px;
        padding: 18px;
        box-shadow: 0 8px 30px rgba(50, 30, 50, 0.06);
      }
      .control-panel {
        display: flex;
        gap: 18px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .control-label {
        margin-right: 10px;
        font-weight: bold;
      }
      .speed-btn {
        padding: 6px 16px;
        border-radius: 12px;
        border: 2px solid #ffb100;
        background: #fff;
        cursor: pointer;
        margin: 0 4px;
        font-size: 14px;
      }
      .speed-btn.active {
        background: #ff71a5;
        border: none;
        color: #fff;
      }
      .question-box {
        background: linear-gradient(180deg, #fff, #fff0f6);
        border-radius: 14px;
        padding: 12px 20px;
        font-size: 34px;
        font-weight: 800;
        color: #ff6a8b;
        box-shadow: 0 6px 12px rgba(255, 110, 160, 0.12);
        min-width: 220px;
        text-align: center;
        margin-top: 12px;
      }
      #balloonArea {
        margin-top: 14px;
        width: 100%;
        height: 360px;
        border-radius: 16px;
        overflow: hidden;
        position: relative;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.6),
          rgba(255, 255, 255, 0.15)
        );
        border: 1px solid rgba(255, 200, 220, 0.4);
      }
      .balloon {
        position: absolute;
        width: 68px;
        height: 68px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        font-weight: 800;
        color: #053d5a;
        text-shadow: 0 0 3px #ffffffaa;
        cursor: pointer;
        background: radial-gradient(
          circle at 35% 35%,
          #ffffffee 8%,
          #8fe2ffdd 40%,
          #3bb8ffdd 85%
        );
        border: 3px solid #47bfff;
        box-shadow: inset -6px -8px 14px rgba(0, 90, 160, 0.18),
          0 0 14px rgba(80, 190, 255, 0.55), 0 8px 18px rgba(0, 60, 100, 0.1);
        user-select: none;
        transform: translateY(0);
        transition: transform 0.14s ease, box-shadow 0.14s ease;
        z-index: 10;
        pointer-events: auto;
      }
      .balloon:hover {
        transform: scale(1.12) translateY(-4px);
        box-shadow: 0 14px 28px rgba(255, 110, 160, 0.18);
      }
      @keyframes floatUp {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(-520px);
          opacity: 0;
        }
      }
      .pop {
        animation: popBalloon 0.65s ease-out forwards;
        transform-origin: center center;
        z-index: 100;
      }
      @keyframes popBalloon {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
        30% {
          transform: scale(1.4) rotate(5deg);
          opacity: 1;
        }
        60% {
          transform: scale(1.8) rotate(-5deg);
          opacity: 0.8;
        }
        100% {
          transform: scale(0) rotate(15deg);
          opacity: 0;
        }
      }
      .candy-splash {
        position: absolute;
        font-size: 24px;
        pointer-events: none;
        transform-origin: center;
        opacity: 1;
        z-index: 200;
      }
      @keyframes candyFly {
        0% {
          opacity: 1;
          transform: translate(0, 0) scale(1) rotate(0deg);
        }
        50% {
          opacity: 1;
          transform: translate(var(--dx-mid, 0), var(--dy-mid, 0)) scale(1.2) rotate(180deg);
        }
        100% {
          opacity: 0;
          transform: translate(var(--dx, 0), var(--dy, 0)) scale(0.5)
            rotate(360deg);
        }
      }
      .controls-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        background: #ff6a8b;
        color: white;
        padding: 8px 12px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: 700;
      }
      .btn.secondary {
        background: #ffd166;
        color: #4b3621;
      }
      .level-badge {
        background: #fff0f0;
        padding: 6px 10px;
        border-radius: 10px;
        font-weight: 800;
        color: #ff6a8b;
      }
    </style>
  </head>
  <body>
    <div id="shootGame">
      <div class="control-panel">
        <div>
          <span class="control-label">‚ö° T·ªëc ƒë·ªô:</span>
          <button class="speed-btn active" data-speed="4500">Ch·∫≠m</button>
          <button class="speed-btn" data-speed="3000">V·ª´a</button>
          <button class="speed-btn" data-speed="1800">Nhanh</button>
        </div>
        <div>üíé <span id="shootReward">0</span></div>
        <div>üèÜ <span id="shootHighScore">0</span></div>
        <div class="controls-row">
          <label>Level</label>
          <div id="levelBadge" class="level-badge">1</div>
        </div>
      </div>

      <div id="shootQuestion" class="question-box" aria-live="polite">
        5 √ó 7 = ?
      </div>
      <div
        id="balloonArea"
        role="application"
        aria-label="khu v·ª±c bong b√≥ng"
      ></div>

      <div
        style="
          margin-top: 12px;
          display: flex;
          gap: 12px;
          justify-content: center;
        "
      >
        <button id="startBtn" class="btn">B·∫Øt ƒë·∫ßu</button>
        <button id="stopBtn" class="btn secondary">D·ª´ng</button>
        <button id="resetHighBtn" class="btn secondary">ƒê·∫∑t l·∫°i k·ª∑ l·ª•c</button>
      </div>
    </div>

    <script>
      (() => {
        const popSound = new Audio(
          "https://assets.mixkit.co/sfx/preview/mixkit-pop-106.mp3"
        );
        popSound.volume = 0.55;

        const balloonArea = document.getElementById("balloonArea");
        const questionEl = document.getElementById("shootQuestion");
        const shootRewardEl = document.getElementById("shootReward");
        const shootHighEl = document.getElementById("shootHighScore");
        const levelBadge = document.getElementById("levelBadge");

        let shootScore = 0;
        let shootHighScore =
          Number(localStorage.getItem("shootHighScore")) || 0;
        shootHighEl.textContent = shootHighScore;

        let shootCorrectAnswer = null,
          spawnIntervalId = null,
          active = false,
          currentLevel = 1,
          balloonIds = 0;
        let usedRecentQuestions = new Set(),
          baseDuration = parseInt(
            document.querySelector(".speed-btn.active").dataset.speed
          );
        let currentAnswerPool = [],
          correctBalloonSpawned = false;

        document.querySelectorAll(".speed-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            document
              .querySelectorAll(".speed-btn")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            baseDuration = parseInt(btn.dataset.speed);
            if (active) restartSpawnInterval();
          });
        });

        document
          .getElementById("startBtn")
          .addEventListener("click", startShootGame);
        document
          .getElementById("stopBtn")
          .addEventListener("click", stopShootGame);
        document
          .getElementById("resetHighBtn")
          .addEventListener("click", () => {
            localStorage.removeItem("shootHighScore");
            shootHighScore = 0;
            shootHighEl.textContent = 0;
          });

        function rand(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function randomFromSet(arr) {
          return arr[Math.floor(Math.random() * arr.length)];
        }

        function startShootGame() {
          stopShootGame();
          shootScore = 0;
          currentLevel = 1;
          levelBadge.textContent = currentLevel;
          shootRewardEl.textContent = shootScore;
          nextQuestion();
          active = true;
        }

        function stopShootGame() {
          active = false;
          clearInterval(spawnIntervalId);
          spawnIntervalId = null;
          balloonArea.innerHTML = "";
          usedRecentQuestions.clear();
        }

        function nextQuestion() {
          // Ch·ªâ x√≥a bong b√≥ng, gi·ªØ l·∫°i k·∫πo ƒëang bay
          const balloons = balloonArea.querySelectorAll(".balloon");
          balloons.forEach((balloon) => balloon.remove());
          
          let a, b, key;
          do {
            a = rand(1, 9);
            b = rand(1, 10);
            key = `${a}x${b}`;
          } while (
            usedRecentQuestions.has(key) &&
            usedRecentQuestions.size < 80
          );
          usedRecentQuestions.add(key);
          if (usedRecentQuestions.size > 80) usedRecentQuestions.clear();
          shootCorrectAnswer = a * b;
          questionEl.textContent = `${a} √ó ${b} = ?`;

          const answers = new Set([shootCorrectAnswer]);
          while (answers.size < 6) answers.add(rand(1, 90));
          currentAnswerPool = [...answers].sort(() => Math.random() - 0.5);

          correctBalloonSpawned = false;
          spawnBalloonBatch();
          restartSpawnInterval();
        }

        function restartSpawnInterval() {
          clearInterval(spawnIntervalId);
          spawnIntervalId = setInterval(() => {
            if (active) spawnBalloonBatch();
          }, Math.max(800, baseDuration));
        }

        function spawnBalloonBatch() {
          const batchSize = rand(3, 5);
          const positions = [];
          const correctIndex = rand(0, batchSize - 1);
          const minDistance = 18; // TƒÉng kho·∫£ng c√°ch t·ªëi thi·ªÉu t·ª´ 12% l√™n 18%

          // L·∫•y danh s√°ch c√°c bong b√≥ng hi·ªán c√≥ ƒë·ªÉ ki·ªÉm tra collision
          const existingBalloons = Array.from(balloonArea.querySelectorAll(".balloon"));
          const areaWidth = balloonArea.offsetWidth || 900; // Fallback n·∫øu ch∆∞a render
          const balloonSize = 68; // K√≠ch th∆∞·ªõc bong b√≥ng
          const minDistancePx = (areaWidth * minDistance) / 100; // Chuy·ªÉn % sang px
          
          for (let i = 0; i < batchSize; i++) {
            let num =
              i === correctIndex
                ? shootCorrectAnswer
                : (() => {
                    let c;
                    do {
                      c = randomFromSet(currentAnswerPool);
                    } while (c === shootCorrectAnswer);
                    return c;
                  })();
            
            let leftPct, bottomOffset;
            let attempts = 0;
            let foundValidPosition = false;
            
            // T√¨m v·ªã tr√≠ kh√¥ng ƒë√® l√™n c√°c bong b√≥ng kh√°c
            do {
              leftPct = rand(5, 85);
              bottomOffset = rand(0, 30);
              
              // T√≠nh to√°n v·ªã tr√≠ pixel c·ªßa bong b√≥ng m·ªõi
              const newLeftPx = (areaWidth * leftPct) / 100;
              
              // Ki·ªÉm tra v·ªõi c√°c v·ªã tr√≠ trong batch hi·ªán t·∫°i
              const tooCloseToBatch = positions.some((p) => {
                const existingLeftPx = (areaWidth * p) / 100;
                return Math.abs(existingLeftPx - newLeftPx) < minDistancePx;
              });
              
              // Ki·ªÉm tra collision v·ªõi c√°c bong b√≥ng ƒëang bay (ki·ªÉm tra v·ªã tr√≠ hi·ªán t·∫°i)
              let hasCollision = false;
              if (existingBalloons.length > 0 && balloonArea.offsetWidth > 0) {
                const areaRect = balloonArea.getBoundingClientRect();
                const newBottomPx = -60 - bottomOffset; // V·ªã tr√≠ bottom c·ªßa bong b√≥ng m·ªõi (√¢m)
                
                hasCollision = existingBalloons.some((balloon) => {
                  const rect = balloon.getBoundingClientRect();
                  
                  // T√≠nh v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi trong balloonArea
                  const balloonLeftPx = rect.left - areaRect.left + rect.width / 2;
                  const newBalloonCenterPx = newLeftPx;
                  
                  // V·ªã tr√≠ bottom hi·ªán t·∫°i c·ªßa bong b√≥ng ƒëang bay (t√≠nh t·ª´ bottom c·ªßa area)
                  const balloonBottomPx = areaRect.bottom - rect.bottom;
                  const newBalloonBottomPx = areaRect.height + newBottomPx;
                  
                  // Kho·∫£ng c√°ch ngang v√† d·ªçc gi·ªØa c√°c t√¢m bong b√≥ng
                  const distanceX = Math.abs(balloonLeftPx - newBalloonCenterPx);
                  const distanceY = Math.abs(balloonBottomPx - newBalloonBottomPx);
                  
                  // Ki·ªÉm tra overlap: n·∫øu g·∫ßn nhau c·∫£ ngang v√† d·ªçc th√¨ c√≥ collision
                  // Ch·ªâ ki·ªÉm tra collision n·∫øu bong b√≥ng ƒëang ·ªü g·∫ßn v·ªã tr√≠ bottom m·ªõi (trong v√πng 150px)
                  if (distanceY < 150) {
                    return distanceX < (balloonSize + 15); // Padding ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng ch·∫°m
                  }
                  
                  return false;
                });
              }
              
              if (!tooCloseToBatch && !hasCollision) {
                foundValidPosition = true;
              }
              
              attempts++;
            } while (!foundValidPosition && attempts < 100);
            
            if (foundValidPosition) {
              positions.push(leftPct);
              spawnBalloon(num, leftPct, bottomOffset);
              if (num === shootCorrectAnswer) correctBalloonSpawned = true;
            }
          }
        }

        function spawnBalloon(num, leftPct = null, bottomOffset = null) {
          const id = ++balloonIds;
          const b = document.createElement("div");
          b.className = "balloon";
          b.dataset.id = id;
          b.textContent = num;

          const palettes = [
            ["#fff6fb", "#ffd7f0"],
            ["#fff9ec", "#fff0d6"],
            ["#f0fff7", "#d8fff0"],
            ["#fff7ff", "#f7e9ff"],
          ];
          const p = palettes[rand(0, palettes.length - 1)];
          b.style.background = `radial-gradient(circle at 28% 28%, ${p[0]}, ${p[1]})`;
          b.style.color = "#7a2a59";
          
          // ƒê·∫∑t v·ªã tr√≠ ngang
          if (leftPct === null) leftPct = rand(5, 85);
          b.style.left = leftPct + "%";
          
          // ƒê·∫∑t z-index tƒÉng d·∫ßn ƒë·ªÉ bong b√≥ng m·ªõi lu√¥n ·ªü tr√™n
          b.style.zIndex = (10 + id).toString();

          const floatDur = Math.max(
            0.9,
            baseDuration / 1000 - (currentLevel - 1) * 0.35
          );
          b.style.animation = `floatUp ${floatDur}s linear forwards`;
          
          // S·ª≠ d·ª•ng bottomOffset n·∫øu ƒë∆∞·ª£c cung c·∫•p, n·∫øu kh√¥ng th√¨ random
          if (bottomOffset !== null) {
            b.style.bottom = (-60 - bottomOffset) + "px";
          } else {
            b.style.bottom = -60 - Math.random() * 30 + "px";
          }

          b.addEventListener("click", (ev) => {
            if (!active) return;
            const val = Number(b.textContent);
            if (val === shootCorrectAnswer) {
              // d·ª´ng float animation v√† n·ªï
              b.style.animation = "";
              explodeBalloon(b);
              // Delay ƒë·ªÉ k·∫πo c√≥ th·ªùi gian hi·ªÉn th·ªã tr∆∞·ªõc khi chuy·ªÉn c√¢u h·ªèi
              setTimeout(() => {
                handleCorrect();
              }, 500);
            } else {
              b.style.transform = "translateY(-6px) scale(1.06)";
              b.style.background = "#ffd7d7";
              setTimeout(() => (b.style.transform = ""), 180);
            }
            ev.stopPropagation();
          });

          // remove bong b√≥ng khi bay h·∫øt n·∫øu ch∆∞a b·ªã click ƒë√∫ng
          b.addEventListener("animationend", () => {
            if (b.parentNode && !b.classList.contains("pop")) b.remove();
          });

          balloonArea.appendChild(b);

          setTimeout(() => {
            if (b.parentNode && !b.classList.contains("pop")) b.remove();
          }, Math.max(6000, floatDur * 1000 + 900));
        }

        function explodeBalloon(balloonEl) {
          // Ph√°t √¢m thanh n·ªï (kh√¥ng ch·∫∑n n·∫øu l·ªói)
          popSound.currentTime = 0;
          popSound.play().catch(() => {
            // B·ªè qua l·ªói n·∫øu kh√¥ng ph√°t ƒë∆∞·ª£c √¢m thanh
          });

          // Th√™m class pop ƒë·ªÉ bong b√≥ng n·ªï
          balloonEl.classList.add("pop");

          // S·ª≠ d·ª•ng requestAnimationFrame ƒë·ªÉ ƒë·∫£m b·∫£o v·ªã tr√≠ ƒë∆∞·ª£c t√≠nh ch√≠nh x√°c
          requestAnimationFrame(() => {
            const areaRect = balloonArea.getBoundingClientRect();
            const rect = balloonEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2 - areaRect.left;
            const centerY = rect.top + rect.height / 2 - areaRect.top;

            // M·∫£ng c√°c lo·∫°i k·∫πo kh√°c nhau
            const candies = ["üç¨", "üç≠", "üç´", "üç∞", "üç™", "‚≠ê", "üí´", "‚ú®"];
            
            // T·∫°o nhi·ªÅu k·∫πo bay ra (tƒÉng t·ª´ 8 l√™n 15)
            const candyCount = 15;
            for (let i = 0; i < candyCount; i++) {
              const c = document.createElement("div");
              c.className = "candy-splash";
              // Ch·ªçn ng·∫´u nhi√™n m·ªôt lo·∫°i k·∫πo
              c.textContent = randomFromSet(candies);
              
              // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu t·∫°i t√¢m bong b√≥ng
              c.style.position = "absolute";
              c.style.left = centerX + "px";
              c.style.top = centerY + "px";
              
              // T·∫°o h∆∞·ªõng bay ng·∫´u nhi√™n v·ªõi g√≥c ph√¢n b·ªë ƒë·ªÅu (360 ƒë·ªô)
              const angle = (i / candyCount) * Math.PI * 2 + Math.random() * 0.3;
              const distance = 120 + Math.random() * 80; // Kho·∫£ng c√°ch bay
              const dx = (Math.cos(angle) * distance).toFixed(0) + "px";
              const dy = (Math.sin(angle) * distance - 30).toFixed(0) + "px"; // H∆°i bay l√™n tr√™n
              const dxMid = (Math.cos(angle) * distance * 0.6).toFixed(0) + "px";
              const dyMid = (Math.sin(angle) * distance * 0.6 - 30).toFixed(0) + "px";
              
              c.style.setProperty("--dx", dx);
              c.style.setProperty("--dy", dy);
              c.style.setProperty("--dx-mid", dxMid);
              c.style.setProperty("--dy-mid", dyMid);
              
              // Th·ªùi gian animation ng·∫´u nhi√™n ƒë·ªÉ t·ª± nhi√™n h∆°n
              const duration = 0.8 + Math.random() * 0.4;
              c.style.animation =
                `candyFly ${duration}s cubic-bezier(.2,.8,.2,1) forwards`;
              
              balloonArea.appendChild(c);

              // X√≥a k·∫πo sau khi animation k·∫øt th√∫c
              setTimeout(() => {
                if (c.parentNode) c.remove();
              }, duration * 1000 + 100);
            }
          });

          // Remove bong b√≥ng sau khi pop animation k·∫øt th√∫c
          balloonEl.addEventListener("animationend", () => {
            if (balloonEl.parentNode) balloonEl.remove();
          });
        }

        function handleCorrect() {
          if (!active) return;
          shootScore++;
          shootRewardEl.textContent = shootScore;
          if (shootScore > shootHighScore) {
            shootHighScore = shootScore;
            localStorage.setItem("shootHighScore", shootHighScore);
            shootHighEl.textContent = shootHighScore;
          }
          if (shootScore % 8 === 0) {
            currentLevel++;
            levelBadge.textContent = currentLevel;
          }
          nextQuestion();
        }

        function initPlaceholder() {
          questionEl.textContent = 'Ch·∫°m "B·∫Øt ƒë·∫ßu" ƒë·ªÉ ch∆°i';
          balloonArea.innerHTML = "";
        }
        initPlaceholder();
      })();
    </script>
  </body>
</html>
